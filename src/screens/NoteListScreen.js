import React from 'react';
import { connect } from 'react-redux';
import { Button, Platform, StyleSheet, Text, View, TouchableOpacity } from 'react-native';
import NoteList from '../components/NoteList';
import ActionButton from 'react-native-action-button';
import actions from '../redux/actions';
import theme from '../theme';
import uuid from 'uuid';

const styles = StyleSheet.create({
    addItemButton: {
        fontSize: 28
    },
    iosAddItemIcon: {
        fontSize: 20,
        color: '#A0A0A0',
        marginRight: 8
    },
    container: {
        backgroundColor: 'white',
        flex: 1
    }
});

const HeaderButton = (props) => {
    return (
        <TouchableOpacity onPress={(event) => props.onPress(event)}>
            <Text style={props.style}>{props.children}</Text>
        </TouchableOpacity>
    );
};

/**
 * The Home Screen - this is a container component built on top of
 * the React Navigation system that is fed the list of notes to be
 * displayed
 *
 * @class NoteListScreen
 * @extends {React.Component}
 */
class NoteListScreen extends React.Component {
    /**
     * Options for react-navigation
     *
     * @static
     * @memberof NoteListScreen
     */
    static navigationOptions = ({ navigation }) => {
        return {
            title: 'Notes',
            headerStyle: {
                backgroundColor: theme.headerBackgroundColor
            },
            headerTintColor: theme.headerForegroundColor,
            headerRight: (Platform.OS === 'ios')
                ? <HeaderButton style={styles.iosAddItemIcon} onPress={() => NoteListScreen.onAddNote(navigation.navigate)}>+</HeaderButton>
                : false
        }
    };

    /**
     * This has to be a static method because it is called in two places - by the floating
     * action button on Android and by the navigation options on iOS.
     * @param {Function} navigate method to call to navigate to a new screen
     */
    static onAddNote(navigate) {
        navigate('details', { noteId: uuid.v4() });
    }

    /**
     * Event handler called when a user tries to press a note.
     *
     * @param {String} noteId the id of the note to be selected
     * @memberof Home
     */
    onViewNote(item) {
        const { navigate } = this.props.navigation;
        navigate('details', { noteId: item.noteId });
    }

    /**
     * Event handler called when a user tries to delete a note.
     *
     * @param {String} noteId the id of the note to be deleted
     * @memberof NoteListScreen
     */
    onDeleteNote(item) {
        this.props.deleteNote(item.noteId);
    }

    /**
     * Part of the React lifecycle that actually renders the component.
     *
     * @returns {JSX.Element} a component tree rendered in JSX
     * @memberof NoteListScreen
     */
    render() {
        // Sometimes, the parameters we feed to the JSX components get
        // unwieldly; we can provide objects instead - this is the props
        // fed to the NoteList component.
        const noteListParams = {
            notes: this.props.notes,
            onViewNote: (item) => this.onViewNote(item),
            onDeleteNote: (item) => this.onDeleteNote(item)
        };

        const actionButtonParams = {
            buttonColor: theme.actionButtonColor,
            onPress: () => NoteListScreen.onAddNote(this.props.navigation.navigate)
        };

        // The rendered component.  Note that if we are on iOS, the Add Item
        // component is rendered in the header.  If we are on Android, then
        // the Add Item component is rendered as a floating action button on
        // the page.
        return (
            <View style={styles.container}>
                <NoteList {...noteListParams} />
                {(Platform.OS === 'android') && <ActionButton {...actionButtonParams} />}
            </View>
        );
    }
}

/**
 * Maps the redux store state to properties required by this container
 * component.  In this case, we only want to see the records that are
 * not deleted.
 *
 * @param {Object} state the redux store state
 */
const mapStateToProps = (state) => {
    return {
        notes: state.notes
    };
};

/**
 * Maps the dispatch method to dispatch the appropriate actions based
 * on the events that will be generated by this container component.
 *
 * @param {Function} dispatch the dispatcher from redux
 */
const mapDispatchToProps = (dispatch) => {
    return {
        deleteNote: (noteId) => dispatch(actions.notes.deleteNote({ noteId }))
    };
};

export default connect(mapStateToProps, mapDispatchToProps)(NoteListScreen);
